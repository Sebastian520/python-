# 4.3 使用数组进行面向数组编程

np.meshgrid函数接收两个一维数组，并根据两个数组的所有（x， y）对生成一个二维矩阵
[X,Y] = meshgrid(x,y) 将向量x和y定义的区域转换成矩阵X和Y,其中矩阵X的行向量是向量x的简单复制，而矩阵Y的列向量是向量y的简单复制
假设x是长度为m的向量，y是长度为n的向量，则最终生成的矩阵X和Y的维度都是 n*m （注意不是m*n）。


```python
import numpy as np
points = np.arange(-5, 5, 0.01)
xs, ys = np.meshgrid(points, points)
xs
```




    array([[-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99],
           [-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99],
           [-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99],
           ...,
           [-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99],
           [-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99],
           [-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99]])




```python
ys
```




    array([[-5.  , -5.  , -5.  , ..., -5.  , -5.  , -5.  ],
           [-4.99, -4.99, -4.99, ..., -4.99, -4.99, -4.99],
           [-4.98, -4.98, -4.98, ..., -4.98, -4.98, -4.98],
           ...,
           [ 4.97,  4.97,  4.97, ...,  4.97,  4.97,  4.97],
           [ 4.98,  4.98,  4.98, ...,  4.98,  4.98,  4.98],
           [ 4.99,  4.99,  4.99, ...,  4.99,  4.99,  4.99]])




```python
z = np.sqrt(xs ** 2 + ys ** 2)
z
```




    array([[7.07106781, 7.06400028, 7.05693985, ..., 7.04988652, 7.05693985,
            7.06400028],
           [7.06400028, 7.05692568, 7.04985815, ..., 7.04279774, 7.04985815,
            7.05692568],
           [7.05693985, 7.04985815, 7.04278354, ..., 7.03571603, 7.04278354,
            7.04985815],
           ...,
           [7.04988652, 7.04279774, 7.03571603, ..., 7.0286414 , 7.03571603,
            7.04279774],
           [7.05693985, 7.04985815, 7.04278354, ..., 7.03571603, 7.04278354,
            7.04985815],
           [7.06400028, 7.05692568, 7.04985815, ..., 7.04279774, 7.04985815,
            7.05692568]])




```python
import matplotlib.pyplot as plt
plt.imshow(z, cmap=plt.cm.gray);plt.colorbar()
plt.title("Image plot of sqrt{x^2 + y^2} for a grid of values")
```




    Text(0.5, 1.0, 'Image plot of sqrt{x^2 + y^2} for a grid of values')




![png](output_5_1.png)


# 将条件逻辑作为数组操作


```python
numpy.where是三元表达式x if condition else y的向量化版本
```

假设cond中的元素为True时，取xarr中的元素值，否则取yarr中的元素值


```python
xarr = np.array([1.1, 1.2, 1.3, 1.4, 1.5])
yarr = np.array([2.1, 2.2, 2.3, 2.4, 2.5])
cond = np.array([True, False, True, True, False])
result = [(x if c else y)
         for x, y, c in zip(xarr, yarr, cond)]
result
```




    [1.1, 2.2, 1.3, 1.4, 2.5]




```python
result = np.where(cond, xarr, yarr)
result
```




    array([1.1, 2.2, 1.3, 1.4, 2.5])



假设有一个随机生成的矩阵，要将其中的正值替换为2，负值替换为-2


```python
arr = np.random.randn(4, 4)
arr
```




    array([[-0.35279196, -1.14748095, -0.55371548,  0.58441251],
           [-0.01678622, -0.33141374, -1.22216   , -0.45543925],
           [-0.71035864, -0.96703023, -0.19880906, -0.24446851],
           [ 0.87145535,  0.24305214,  1.80506063,  1.00562675]])




```python
arr > 0
```




    array([[False, False, False,  True],
           [False, False, False, False],
           [False, False, False, False],
           [ True,  True,  True,  True]])




```python
np.where(arr > 0, 2, -2)
```




    array([[-2, -2, -2,  2],
           [-2, -2, -2, -2],
           [-2, -2, -2, -2],
           [ 2,  2,  2,  2]])



传递给np.where的数组既可以是同等大小的数组，也可以是标量


```python
np.where(arr > 0, 2, arr)#仅将正值设为2
```




    array([[-0.35279196, -1.14748095, -0.55371548,  2.        ],
           [-0.01678622, -0.33141374, -1.22216   , -0.45543925],
           [-0.71035864, -0.96703023, -0.19880906, -0.24446851],
           [ 2.        ,  2.        ,  2.        ,  2.        ]])



# 数学和统计方法


```python
arr = np.arange(-2, 2, 0.5).reshape(2, 4)
arr
```




    array([[-2. , -1.5, -1. , -0.5],
           [ 0. ,  0.5,  1. ,  1.5]])




```python
arr.mean()
```




    -0.25




```python
arr.sum()
```




    -2.0



mean,sum等函数可接收一个可选参数axis，用于计算给定轴向上的统计值，形成一个下降一维度的数组
1表示横轴，方向从左到右；0表示纵轴，方向从上到下。当axis=1时，数组的变化是横向的，而体现出来的是列的增加或者减少。
当axis=1时，如果是求平均，那么是从左到右横向求平均；如果是拼接，那么也是左右横向拼接；如果是drop，那么也是横向发生变化，体现为列的减少。


```python
arr.mean(axis=0)
```




    array([-1. , -0.5,  0. ,  0.5])




```python
arr.sum(axis=1)
```




    array([-5.,  3.])



cumsum,cumprod并不会聚合，而是产生一个中间结果：


```python
arr = np.array([0, 1, 2, 3, 4, 5, 6, 7])
arr.cumsum()
```




    array([ 0,  1,  3,  6, 10, 15, 21, 28], dtype=int32)



多维数组中cumsum这样的累计函数可以在指定轴向上根据较低维度的切片进行部分聚合：


```python
arr = np.array([[0, 1, 2], [3, 4, 5],[6, 7, 8]])
arr
```




    array([[0, 1, 2],
           [3, 4, 5],
           [6, 7, 8]])




```python
arr.cumsum()
```




    array([ 0,  1,  3,  6, 10, 15, 21, 28, 36], dtype=int32)




```python
arr.cumsum(axis=0)#纵向求和
```




    array([[ 0,  1,  2],
           [ 3,  5,  7],
           [ 9, 12, 15]], dtype=int32)




```python
arr.cumsum(axis=1)#横向求和
```




    array([[ 0,  1,  3],
           [ 3,  7, 12],
           [ 6, 13, 21]], dtype=int32)




```python
arr.cumprod(axis=1)#横向求积
```




    array([[  0,   0,   0],
           [  3,  12,  60],
           [  6,  42, 336]], dtype=int32)



# 布尔值数组的方法

sum可以用于计算布尔值数组中的True的个数


```python
arr = np.random.randn(100)
(arr > 0).sum()
```




    47



any检查数组中是否至少有一个True，all检查每个值都是True


```python
bools = np.array([False, False, True,False])
bools.any()
```




    True




```python
bools.all()
```




    False



# 排序


```python
arr = np.random.randn(6)
arr
```




    array([-0.42098978, -0.65791361,  0.42713073,  0.91932294,  0.11741368,
           -0.96666459])




```python
arr.sort()
arr
```




    array([-0.96666459, -0.65791361, -0.42098978,  0.11741368,  0.42713073,
            0.91932294])



多维数组中根据传递的axis的值，沿着轴向对每个一维数据段进行排序


```python
arr = np.random.randn(5, 3)
arr
```




    array([[ 1.03351032, -0.12808527, -0.23475779],
           [ 1.06034429, -0.03249336, -0.00318133],
           [-0.28898151,  0.20717861,  0.92033188],
           [ 0.73522446, -0.42210767,  0.14336192],
           [ 0.23237835, -0.40737783, -0.19919937]])




```python
arr.sort(1) #按行排序
arr
```




    array([[-0.23475779, -0.12808527,  1.03351032],
           [-0.03249336, -0.00318133,  1.06034429],
           [-0.28898151,  0.20717861,  0.92033188],
           [-0.42210767,  0.14336192,  0.73522446],
           [-0.40737783, -0.19919937,  0.23237835]])



# 唯一值与其他集合逻辑

np.unique返回的是数组中唯一值排序后形成的数组


```python
names = np.array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'])
np.unique(names)
```




    array(['Bob', 'Joe', 'Will'], dtype='<U4')




```python
ints = np.array([3, 3, 3, 2, 2, 1, 1, 4, 4])
np.unique(ints)
```




    array([1, 2, 3, 4])



np.in1d可以检查一个数组中的值是否在另一个数组中，并返回一个布尔值数组


```python
values = np.array([6, 0, 0, 3, 2, 5, 6])
np.in1d(values, [2, 3, 6])
```




    array([ True, False, False,  True,  True, False,  True])


